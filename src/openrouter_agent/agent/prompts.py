PROMPT_PARSE_REQUEST = """Ты получаешь запрос от клиента по созданию или модификации программного проекта. Твоя задача извлечь из запроса структурированную информацию.

Запрос клиента:
{client_request}

Контекст проекта (если доступен):
{project_digest}

Извлеки следующую информацию:

1. GOAL: одно предложение, описывающее главную цель запроса
2. ACTIONS: список конкретных действий которые клиент хочет выполнить. Каждое действие должно быть проверяемым
3. CONSTRAINTS: ограничения которые клиент указал явно (технологические, временные, платформенные)
4. IMPLICIT_REQUIREMENTS: требования которые не указаны явно но вытекают из контекста запроса и проекта
5. PRIORITY: high/medium/low на основе тона и срочности запроса
6. SCOPE: четкие границы задачи, что входит и что не входит

ВАЖНО: Поле clarification_needed заполняй ТОЛЬКО если запрос настолько размытый, что невозможно определить ни одно конкретное действие (ACTIONS пустой) и нельзя определить scope. В остальных случаях оставляй clarification_needed пустым массивом и делай разумные предположения на основе контекста.

Формат ответа строго JSON:
{{
  "goal": "строка",
  "actions": ["строка"],
  "constraints": ["строка"],
  "implicit_requirements": ["строка"],
  "priority": "high|medium|low",
  "scope": {{
    "included": ["строка"],
    "excluded": ["строка"]
  }},
  "clarification_needed": []
}}
"""

PROMPT_PROJECT_DIGEST = """Ты анализируешь кодовую базу программного проекта (или пустую папку) в контексте конкретного запроса на создание или модификацию.

Структура файлов проекта:
{file_tree}

Содержимое ключевых файлов:
{file_contents}

Запрос на создание/модификацию:
{parsed_request}

ВАЖНО - если структура файлов пустая или содержит 0 файлов:
- Это проект создаётся с нуля
- Определи стек, язык, фреймворки и инфраструктуру из запроса клиента
- В поле architecture_notes явно укажи "Проект создаётся с нуля. Необходимо инициализировать полную структуру проекта."
- В relevant_files перечисли ВСЕ файлы которые нужно создать для типового проекта этого стека, включая:
  * Файл манифеста зависимостей (package.json / requirements.txt / pyproject.toml / Cargo.toml и т.д.)
  * Конфигурационные файлы фреймворка (hardhat.config.js / tsconfig.json / .eslintrc и т.д.)
  * Файл окружения (.env.example)
  * Скрипты запуска и деплоя
  * Структуру директорий (contracts/, src/, test/, scripts/ и т.д.)

Создай вытяжку проекта (Project Digest) которая содержит:

1. PROJECT_NAME: название проекта из конфигурации или корневой директории
2. STACK: язык, фреймворки, инфраструктура, базы данных
3. STRUCTURE: точки входа, конфигурационные файлы, ключевые модули с кратким описанием назначения каждого
4. DEPENDENCIES: внешние зависимости проекта с версиями если указаны
5. ARCHITECTURE_NOTES: краткое описание архитектурного подхода (или "с нуля" если проект пустой)
6. RELEVANT_FILES: файлы которые будут затронуты или релевантны запросу. Для каждого файла укажи путь и краткое описание почему он релевантен
7. POTENTIAL_ISSUES: проблемы которые могут возникнуть при выполнении запроса

Формат ответа строго JSON:
{{
  "project_name": "строка",
  "stack": {{
    "language": "строка",
    "frameworks": ["строка"],
    "infrastructure": ["строка"],
    "databases": ["строка"]
  }},
  "structure": {{
    "entry_points": [{{"path": "строка", "description": "строка"}}],
    "config_files": [{{"path": "строка", "description": "строка"}}],
    "key_modules": [{{"path": "строка", "description": "строка"}}]
  }},
  "dependencies": [{{"name": "строка", "version": "строка"}}],
  "architecture_notes": "строка",
  "relevant_files": [{{"path": "строка", "relevance": "строка"}}],
  "potential_issues": ["строка"]
}}
"""

PROMPT_CHECKLIST = """На основе вытяжки проекта и запроса клиента создай чеклист задач для создания или модификации проекта.

Вытяжка проекта:
{project_digest}

Запрос клиента:
{parsed_request}

Правила создания чеклиста:

1. Каждая задача должна быть атомарной
2. Каждая задача должна иметь проверяемый критерий приемки
3. Задачи сгруппированы по категориям: ANALYSIS, MODIFICATION, CREATION, DELETION, CONFIGURATION, VERIFICATION
4. Внутри каждой категории задачи упорядочены по зависимостям
5. Если задача зависит от другой задачи, это указано явно
6. Категория ANALYSIS идет первой, VERIFICATION последней

КРИТИЧЕСКИ ВАЖНО - если проект создаётся с нуля (architecture_notes содержит "с нуля"):
- ПЕРВОЙ задачей в категории CONFIGURATION ОБЯЗАТЕЛЬНО должна быть инициализация манифеста зависимостей:
  * Для Node.js/Hardhat проектов: создание package.json с полным списком зависимостей
  * Для Python: создание requirements.txt или pyproject.toml
  * Для Rust: создание Cargo.toml
  * И т.д. согласно стеку
- Затем задачи создания конфигурационных файлов фреймворка
- Затем задачи создания структуры директорий
- Только после этого - задачи создания бизнес-логики

Минимальное количество задач: 5. Максимальное количество задач: 20.
Для проекта с нуля всегда включай задачи: инициализация зависимостей, создание конфигурации, создание структуры директорий, создание основного кода, тестирование.

Для каждой задачи укажи:
- id: уникальный идентификатор (формат CAT-NNN, например MOD-001)
- category: категория из списка выше
- title: краткое название
- description: описание что конкретно нужно сделать
- affected_files: список файлов которые затрагивает задача
- depends_on: список id задач от которых зависит эта задача
- acceptance_criteria: как проверить что задача выполнена

Формат ответа строго JSON:
{{
  "checklist": [
    {{
      "id": "строка",
      "category": "ANALYSIS|MODIFICATION|CREATION|DELETION|CONFIGURATION|VERIFICATION",
      "title": "строка",
      "description": "строка",
      "affected_files": ["строка"],
      "depends_on": ["строка"],
      "acceptance_criteria": "строка"
    }}
  ],
  "total_tasks": 0
}}
"""

PROMPT_WALKTHROUGH = """На основе вытяжки проекта, запроса клиента и чеклиста задач создай Walkthrough документ.

Вытяжка проекта:
{project_digest}

Запрос клиента:
{parsed_request}

Чеклист задач:
{checklist}

Правила создания walkthrough:

1. Документ группируется по функциональным блокам, а не по файлам
2. Для каждого функционального блока укажи:
   - Название блока
   - Цель: зачем эти изменения нужны
   - Затрагиваемые файлы с указанием типа операции (new, modified, deleted)
   - Описание изменений: что именно меняется и почему
   - Связь с чеклистом: id задач из чеклиста которые покрывает этот блок
   - Риски: что может пойти не так
3. В конце документа добавь секцию верификации
4. ОБЯЗАТЕЛЬНО: каждая задача из чеклиста должна быть покрыта хотя бы одним блоком.
   Перед формированием ответа явно пройдись по всем id из чеклиста и убедись что каждый из них
   присутствует хотя бы в одном поле checklist_ids. Если какой-то id не покрыт - создай для него отдельный блок.

Формат ответа строго JSON:
{{
  "title": "строка",
  "summary": "строка",
  "blocks": [
    {{
      "name": "строка",
      "purpose": "строка",
      "files": [
        {{
          "path": "строка",
          "operation": "new|modified|deleted",
          "changes_description": "строка"
        }}
      ],
      "checklist_ids": ["строка"],
      "risks": ["строка"]
    }}
  ],
  "verification": {{
    "automated_checks": ["строка"],
    "manual_checks": ["строка"]
  }}
}}
"""

PROMPT_IMPLEMENTATION_PLAN = """На основе собранной информации создай детальный план имплементации.

Вытяжка проекта:
{project_digest}

Запрос клиента:
{parsed_request}

Чеклист задач:
{checklist}

Walkthrough:
{walkthrough}

Правила создания плана:

1. План состоит из пронумерованных шагов. Каждый шаг это одно конкретное действие.
2. МАКСИМАЛЬНОЕ количество шагов: 12. Если задач больше - объединяй логически связанные в один шаг.
3. Для каждого шага укажи:
   - step_number: порядковый номер
   - checklist_id: id задачи из чеклиста
   - action_type: тип действия (create_file, modify_file, delete_file, run_command, verify)
   - target: путь к файлу или команда
   - description: описание что нужно сделать на уровне бизнес-логики
   - details: для modify_file - какие секции затрагиваются; для create_file - описание полной структуры содержимого; для run_command - ПОЛНАЯ команда для выполнения
   - rollback: как откатить это действие
4. Шаги упорядочены так чтобы проект оставался работоспособным после каждого шага.
5. КРИТИЧЕСКИ ВАЖНО - если проект создаётся с нуля:
   - Первым шагом ОБЯЗАТЕЛЬНО должно идти создание package.json (или аналога для стека) с ПОЛНЫМ списком зависимостей
   - Вторым шагом - npm install (или аналог) для установки зависимостей
   - Только после этого создание конфигураций и бизнес-логики
   - Для run_command шагов с тестами: убедись что тестируемый код уже создан в предыдущих шагах
6. После каждого логического блока добавь шаг верификации (action_type=verify).
7. В начале плана добавь секцию prerequisites.
8. В конце плана добавь секцию review_required.

Формат ответа строго JSON:
{{
  "prerequisites": ["строка"],
  "steps": [
    {{
      "step_number": 1,
      "checklist_id": "строка",
      "action_type": "create_file|modify_file|delete_file|run_command|verify",
      "target": "строка",
      "description": "строка",
      "details": "строка",
      "rollback": "строка"
    }}
  ],
  "review_required": [
    {{
      "item": "строка",
      "description": "строка"
    }}
  ]
}}
"""

PROMPT_REVIEW_COMMENTS = """Клиент оставил комментарии к сгенерированным документам планирования. Проанализируй комментарии и определи какие изменения нужно внести.

Комментарии клиента:
{client_comments}

Текущий чеклист:
{checklist}

Текущий walkthrough:
{walkthrough}

Текущий план имплементации:
{implementation_plan}

Для каждого комментария определи:

1. comment_type: тип комментария
   - "approve" - клиент одобряет без замечаний
   - "minor_edit" - мелкая правка, не меняет scope
   - "major_change" - существенное изменение, меняет scope или подход
   - "rejection" - клиент хочет отклонить и начать заново

2. affected_documents: какие документы затронуты (checklist, walkthrough, implementation_plan)
3. changes: конкретные изменения которые нужно внести
4. regeneration_needed: нужна ли полная перегенерация документа (устанавливай true только при major_change или rejection, иначе false)

Если комментарии противоречат друг другу, отметь это в поле conflicts.

Формат ответа строго JSON:
{{
  "comments_parsed": [
    {{
      "original_text": "строка",
      "comment_type": "approve|minor_edit|major_change|rejection",
      "affected_documents": ["строка"],
      "changes": ["строка"],
      "regeneration_needed": false
    }}
  ],
  "conflicts": ["строка"],
  "overall_status": "approved|needs_revision|rejected",
  "documents_to_regenerate": ["строка"]
}}
"""

PROMPT_EXECUTE_STEP = """Выполни один шаг из плана имплементации, используя доступные тебе инструменты.

Шаг для выполнения:
{step}

Контекст проекта:
{project_digest}

Текущее содержимое целевого файла (если применимо):
{current_file_content}

Лог предыдущих шагов:
{previous_steps_log}

Правила выполнения:

ВАЖНО: ИСПОЛЬЗУЙ ИНСТРУМЕНТЫ (write_file, edit_file, execute_command и т.д.) для реализации этого шага!
Не возвращай JSON структуру с описанием изменений. Твоя задача - физически внести изменения в файлы проекта (или создать новые) с полным, рабочим кодом.

БЕЗОПАСНОСТЬ ПУТЕЙ: Все пути которые ты передаёшь в инструменты должны быть относительными (например "contracts/Token.sol", "package.json", "test/Token.test.js"). Абсолютно запрещено использовать пути вне директории проекта.

1. Если action_type = create_file: используй write_file для создания нового файла с ПОЛНЫМ кодом (не оставляй комментарии вроде "тут будет код"). Если это первый шаг и проект с нуля - создай полноценный package.json с реальными зависимостями и корректными версиями.

2. Если action_type = modify_file: сначала используй read_file для чтения текущего содержимого, затем edit_file или multi_edit_file для внесения точечных изменений. Если файл для модификации не существует - создай его с нуля с помощью write_file.

3. Если action_type = delete_file: используй delete_file.

4. Если action_type = run_command: используй execute_command. Перед запуском тестов убедись что тестируемые файлы существуют. Если нужен package.json для npm install - убедись что он создан. Проверь результат команды.

5. Если action_type = verify: выполни нужные проверки через доступные инструменты (read_file для проверки содержимого, execute_command для запуска тестов).

ЗАПРЕТ: Не используй search_files бесконечно. Если файл не найден - значит его нужно создать.

Когда завершишь - верни краткий текстовый отчет о том что было сделано (какие файлы созданы/изменены, какие тесты запущены и каков результат).
"""
