# Промты для генерации документов

## Общие принципы

Все промты ниже являются универсальными и не привязаны к конкретному стеку, языку программирования или типу проекта. Переменные обозначены в фигурных скобках

Каждый промт содержит секцию с входными данными, инструкцию для LLM, описание ожидаемого формата выхода и критерии качества

---

## Промт 0. Парсинг запроса клиента

### Назначение
Преобразование свободного текста клиента в структурированный формат

### Входные переменные
- `{client_request}` текст запроса клиента
- `{project_digest}` вытяжка проекта (может быть пустой если вызывается до исследования)

### Текст промта

```
Ты получаешь запрос от клиента по модификации программного проекта. Твоя задача извлечь из запроса структурированную информацию

Запрос клиента:
{client_request}

Контекст проекта (если доступен):
{project_digest}

Извлеки следующую информацию:

1. GOAL: одно предложение, описывающее главную цель запроса
2. ACTIONS: список конкретных действий которые клиент хочет выполнить. Каждое действие должно быть проверяемым
3. CONSTRAINTS: ограничения которые клиент указал явно (технологические, временные, платформенные)
4. IMPLICIT_REQUIREMENTS: требования которые не указаны явно но вытекают из контекста запроса и проекта
5. PRIORITY: high/medium/low на основе тона и срочности запроса
6. SCOPE: чёткие границы задачи, что входит и что не входит

Если запрос слишком размытый чтобы определить ACTIONS или SCOPE, верни поле CLARIFICATION_NEEDED со списком конкретных вопросов которые нужно задать клиенту

Формат ответа строго JSON
```

### Формат выхода

```json
{
  "goal": "строка",
  "actions": ["строка"],
  "constraints": ["строка"],
  "implicit_requirements": ["строка"],
  "priority": "high|medium|low",
  "scope": "строка",
  "clarification_needed": ["строка"] // опционально
}
```

---

## Промт 1. Исследование и вытяжка проекта

### Назначение
Формирование стандартизированной вытяжки из кодовой базы проекта

### Входные переменные
- `{file_tree}` дерево файлов проекта
- `{file_contents}` содержимое прочитанных ключевых файлов
- `{parsed_request}` структурированный запрос клиента из Промта 0

### Текст промта

```
Ты анализируешь кодовую базу программного проекта в контексте конкретного запроса на модификацию

Структура файлов проекта:
{file_tree}

Содержимое ключевых файлов:
{file_contents}

Запрос на модификацию:
{parsed_request}

Создай вытяжку проекта (Project Digest) которая содержит:

1. PROJECT_NAME: название проекта из конфигурации или корневой директории
2. STACK: язык, фреймворки, инфраструктура, базы данных
3. STRUCTURE: точки входа, конфигурационные файлы, ключевые модули с кратким описанием назначения каждого
4. DEPENDENCIES: внешние зависимости проекта с версиями если указаны
5. ARCHITECTURE_NOTES: краткое описание архитектурного подхода (монолит, микросервисы, модульная структура)
6. RELEVANT_FILES: файлы которые будут затронуты или релевантны запросу клиента. Для каждого файла укажи путь и краткое описание почему он релевантен
7. POTENTIAL_ISSUES: проблемы которые могут возникнуть при выполнении запроса (конфликты зависимостей, устаревший код, отсутствующие тесты, хрупкие связи между модулями)

Фокусируйся на том что релевантно запросу клиента. Не описывай файлы и модули которые не будут затронуты если в этом нет необходимости для понимания контекста

Формат ответа строго JSON
```

### Формат выхода

```json
{
  "project_name": "строка",
  "stack": {
    "language": "строка",
    "frameworks": ["строка"],
    "infrastructure": ["строка"],
    "databases": ["строка"]
  },
  "structure": {
    "entry_points": [{"path": "строка", "description": "строка"}],
    "config_files": [{"path": "строка", "description": "строка"}],
    "key_modules": [{"path": "строка", "description": "строка"}]
  },
  "dependencies": [{"name": "строка", "version": "строка"}],
  "architecture_notes": "строка",
  "relevant_files": [{"path": "строка", "relevance": "строка"}],
  "potential_issues": ["строка"]
}
```

---

## Промт 2. Генерация чеклиста задач

### Назначение
Создание структурированного чеклиста атомарных задач для выполнения запроса клиента

### Входные переменные
- `{project_digest}` вытяжка проекта из Промта 1
- `{parsed_request}` структурированный запрос клиента из Промта 0

### Текст промта

```
На основе вытяжки проекта и запроса клиента создай чеклист задач для модификации проекта

Вытяжка проекта:
{project_digest}

Запрос клиента:
{parsed_request}

Правила создания чеклиста:

1. Каждая задача должна быть атомарной, то есть она либо выполнена полностью либо не выполнена совсем
2. Каждая задача должна иметь проверяемый критерий приёмки
3. Задачи сгруппированы по категориям. Стандартные категории: ANALYSIS (исследование перед изменениями), MODIFICATION (изменение существующих файлов), CREATION (создание новых файлов), DELETION (удаление файлов или кода), CONFIGURATION (настройка окружения, конфигов, зависимостей), VERIFICATION (проверка результатов)
4. Внутри каждой категории задачи упорядочены по зависимостям. Задача не может стоять раньше задачи от которой она зависит
5. Если задача зависит от другой задачи, это указано явно
6. Категория ANALYSIS всегда идёт первой, VERIFICATION всегда последней

Для каждой задачи укажи:
- id: уникальный идентификатор (формат CAT-NNN, например MOD-001)
- category: категория из списка выше
- title: краткое название
- description: описание что конкретно нужно сделать
- affected_files: список файлов которые затрагивает задача
- depends_on: список id задач от которых зависит эта задача (пустой если нет зависимостей)
- acceptance_criteria: как проверить что задача выполнена

Формат ответа строго JSON
```

### Формат выхода

```json
{
  "checklist": [
    {
      "id": "строка",
      "category": "ANALYSIS|MODIFICATION|CREATION|DELETION|CONFIGURATION|VERIFICATION",
      "title": "строка",
      "description": "строка",
      "affected_files": ["строка"],
      "depends_on": ["строка"],
      "acceptance_criteria": "строка"
    }
  ],
  "total_tasks": "число",
  "categories_summary": {
    "ANALYSIS": "число",
    "MODIFICATION": "число",
    "CREATION": "число",
    "DELETION": "число",
    "CONFIGURATION": "число",
    "VERIFICATION": "число"
  }
}
```

---

## Промт 3. Генерация Walkthrough

### Назначение
Создание документа описывающего все изменения в контексте проекта, для ревью и будущей документации

### Входные переменные
- `{project_digest}` вытяжка проекта из Промта 1
- `{parsed_request}` структурированный запрос клиента из Промта 0
- `{checklist}` чеклист задач из Промта 2

### Текст промта

```
На основе вытяжки проекта, запроса клиента и чеклиста задач создай Walkthrough документ. Это документ который описывает что, где и зачем меняется в проекте

Вытяжка проекта:
{project_digest}

Запрос клиента:
{parsed_request}

Чеклист задач:
{checklist}

Правила создания walkthrough:

1. Документ группируется по функциональным блокам, а не по файлам. Функциональный блок это логическая единица изменений объединённая общей целью (например "Локализация", "Докеризация", "Очистка кодовой базы")

2. Для каждого функционального блока укажи:
   - Название блока
   - Цель: зачем эти изменения нужны
   - Затрагиваемые файлы с указанием типа операции (новый, изменён, удалён) для каждого
   - Описание изменений: что именно меняется в каждом файле и почему
   - Связь с чеклистом: id задач из чеклиста которые покрывает этот блок
   - Риски: что может пойти не так при этих изменениях

3. В конце документа добавь секцию верификации с описанием как проверить что все изменения применены корректно

4. Каждая задача из чеклиста должна быть покрыта хотя бы одним блоком walkthrough. Если есть задачи из чеклиста которые не вписываются ни в один блок, создай для них отдельный блок

Формат ответа строго JSON
```

### Формат выхода

```json
{
  "title": "строка, название walkthrough",
  "summary": "строка, краткое описание всех изменений в 2-3 предложения",
  "blocks": [
    {
      "name": "строка",
      "purpose": "строка",
      "files": [
        {
          "path": "строка",
          "operation": "new|modified|deleted",
          "changes_description": "строка"
        }
      ],
      "checklist_ids": ["строка"],
      "risks": ["строка"]
    }
  ],
  "verification": {
    "automated_checks": ["строка"],
    "manual_checks": ["строка"]
  }
}
```

---

## Промт 4. Генерация плана имплементации

### Назначение
Создание пошагового плана действий готового к выполнению агентом или разработчиком

### Входные переменные
- `{project_digest}` вытяжка проекта из Промта 1
- `{parsed_request}` структурированный запрос клиента из Промта 0
- `{checklist}` чеклист задач из Промта 2
- `{walkthrough}` walkthrough из Промта 3

### Текст промта

```
На основе всей собранной информации создай детальный план имплементации. Это документ по которому агент или разработчик будет непосредственно выполнять работу

Вытяжка проекта:
{project_digest}

Запрос клиента:
{parsed_request}

Чеклист задач:
{checklist}

Walkthrough:
{walkthrough}

Правила создания плана:

1. План состоит из пронумерованных шагов. Каждый шаг это одно конкретное действие

2. Для каждого шага укажи:
   - step_number: порядковый номер
   - checklist_id: id задачи из чеклиста которую этот шаг выполняет (один шаг может покрывать одну задачу, одна задача может требовать несколько шагов)
   - action_type: тип действия (create_file, modify_file, delete_file, run_command, verify)
   - target: путь к файлу или команда
   - description: описание что нужно сделать на уровне бизнес-логики, без конкретного кода
   - details: для modify_file какие секции файла затрагиваются и как. Для create_file описание структуры нового файла. Для run_command полная команда. Для verify описание проверки
   - rollback: как откатить это действие если оно привело к ошибке

3. Шаги упорядочены так чтобы проект оставался работоспособным после каждого шага (насколько возможно)

4. После каждого логического блока шагов (соответствующего блоку из walkthrough) добавь шаг верификации

5. В начале плана добавь секцию prerequisites с описанием того что должно быть готово перед началом работы

6. В конце плана добавь секцию review_required с описанием того что клиент должен проверить вручную после завершения всех шагов

Формат ответа строго JSON
```

### Формат выхода

```json
{
  "prerequisites": ["строка"],
  "steps": [
    {
      "step_number": "число",
      "checklist_id": "строка",
      "action_type": "create_file|modify_file|delete_file|run_command|verify",
      "target": "строка",
      "description": "строка",
      "details": "строка",
      "rollback": "строка"
    }
  ],
  "review_required": [
    {
      "item": "строка",
      "description": "строка"
    }
  ],
  "estimated_steps_total": "число"
}
```

---

## Промт 5. Обработка комментариев клиента

### Назначение
Парсинг комментариев клиента к сгенерированным документам и определение необходимых изменений

### Входные переменные
- `{client_comments}` комментарии клиента в свободной форме
- `{checklist}` текущий чеклист
- `{walkthrough}` текущий walkthrough
- `{implementation_plan}` текущий план имплементации

### Текст промта

```
Клиент оставил комментарии к сгенерированным документам планирования. Проанализируй комментарии и определи какие изменения нужно внести

Комментарии клиента:
{client_comments}

Текущий чеклист:
{checklist}

Текущий walkthrough:
{walkthrough}

Текущий план имплементации:
{implementation_plan}

Для каждого комментария определи:

1. comment_type: тип комментария
   - "approve" клиент одобряет без замечаний
   - "minor_edit" мелкая правка формулировки или порядка, не меняет scope
   - "major_change" существенное изменение, меняет scope или подход
   - "rejection" клиент хочет отклонить и начать заново

2. affected_documents: какие документы затронуты (checklist, walkthrough, implementation_plan)

3. changes: конкретные изменения которые нужно внести

4. regeneration_needed: нужна ли полная перегенерация документа или достаточно точечных правок

Если комментарии противоречат друг другу, отметь это в поле conflicts и предложи как разрешить противоречие

Формат ответа строго JSON
```

### Формат выхода

```json
{
  "comments_parsed": [
    {
      "original_text": "строка",
      "comment_type": "approve|minor_edit|major_change|rejection",
      "affected_documents": ["строка"],
      "changes": ["строка"],
      "regeneration_needed": true/false
    }
  ],
  "conflicts": ["строка"],
  "overall_status": "approved|needs_revision|rejected",
  "documents_to_regenerate": ["строка"],
  "documents_to_patch": ["строка"]
}
```

---

## Промт 6. Выполнение шага имплементации

### Назначение
Генерация конкретного кода или конфигурации для одного шага плана имплементации

### Входные переменные
- `{step}` текущий шаг из плана имплементации
- `{project_digest}` вытяжка проекта
- `{current_file_content}` текущее содержимое файла (для modify_file)
- `{previous_steps_log}` лог выполнения предыдущих шагов

### Текст промта

```
Выполни один шаг из плана имплементации

Шаг для выполнения:
{step}

Контекст проекта:
{project_digest}

Текущее содержимое целевого файла (если применимо):
{current_file_content}

Лог предыдущих шагов:
{previous_steps_log}

Правила выполнения:

1. Если action_type = create_file, верни полное содержимое нового файла
2. Если action_type = modify_file, верни только изменённые секции с достаточным контекстом для точного определения места вставки. Формат: указание строки или блока кода который нужно заменить и на что
3. Если action_type = delete_file, подтверди удаление и укажи нужно ли обновить импорты в других файлах
4. Если action_type = run_command, верни команду и ожидаемый результат
5. Если action_type = verify, верни описание проверки и команды для её выполнения

Не меняй ничего что не описано в шаге. Минимальные изменения

Формат ответа строго JSON
```

### Формат выхода

```json
{
  "step_number": "число",
  "action_type": "строка",
  "result": {
    "file_content": "строка (для create_file)",
    "modifications": [
      {
        "location": "строка, описание места в файле",
        "old_content": "строка",
        "new_content": "строка"
      }
    ],
    "command": "строка (для run_command)",
    "expected_output": "строка",
    "verification_result": "строка (для verify)"
  },
  "side_effects": ["строка, описание побочных эффектов если есть"],
  "status": "success|needs_clarification",
  "notes": "строка"
}
```
